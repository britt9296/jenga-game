<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jenga 2D â€” Independent Squares Tower</title>
  <style>
    :root { --wood:#c77d4a; --bg:#f7f7f7; }
    * { margin:0; padding:0; box-sizing:border-box; }
    body { background:var(--bg); overflow:hidden; font-family:system-ui,sans-serif; }
    canvas { display:block; }
    #btn {
      position:fixed; top:1rem; right:1rem;
      padding:.6rem 1rem;
      background:#2c3e50; color:#fff; border:0; border-radius:.5rem;
      cursor:pointer; font-size:1rem; z-index:10;
    }
  </style>
</head>
<body>
  <button id="btn">Restart ðŸ”„</button>
  <canvas id="world"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, World, Bodies, Body, Mouse, MouseConstraint } = Matter;
    const W = () => innerWidth, H = () => innerHeight;
    let engine, world, render, runner;

    function buildTowerSlowly(rows = 15, onComplete) {
      const blockW = 90, blockH = 30;
      const squareSize = 30;
      const gap = 0;  // No gap between squares for better support
      const rowHeight = blockH;
      const groundHeight = 40;
      const groundTopY = H() - groundHeight;
      const startY = groundTopY - blockH / 2;

      let i = 0;

      const interval = setInterval(() => {
        const y = startY - i * (rowHeight + 0.5); // Tiny vertical gap to avoid compression

        if (i % 2 === 0) {
          // Horizontal plank
          const block = Bodies.rectangle(W() / 2, y, blockW, blockH, {
            isStatic: true,
            inertia: Infinity,
            restitution: 0,
            friction: 1.0,
            frictionStatic: 1.0,
            frictionAir: 0.1,
            density: 0.005,
            render: {
              fillStyle: getComputedStyle(document.body).getPropertyValue('--wood')
            }
          });
          World.add(world, block);
        } else {
          // 3 independent squares
          const spacing = squareSize + gap;
          for (let j = -1; j <= 1; j++) {
            const x = W() / 2 + j * spacing;
            const square = Bodies.rectangle(x, y, squareSize, squareSize, {
              isStatic: true,
              inertia: Infinity,
              restitution: 0,
              friction: 1.0,
              frictionStatic: 1.0,
              frictionAir: 0.1,
              density: 0.005,
              render: {
                fillStyle: getComputedStyle(document.body).getPropertyValue('--wood')
              }
            });
            World.add(world, square);
          }
        }

        i++;
        if (i >= rows) {
          clearInterval(interval);

          // Nudge all static bodies (except ground) slightly upward to avoid overlap compression
          for (let body of world.bodies) {
            if (body.isStatic && body.position.y < H() - 60) {
              Body.translate(body, { x: 0, y: -0.1 });
            }
          }

          // After a short delay, make bodies dynamic and zero velocities to reduce sudden sliding
          setTimeout(() => {
            for (let body of world.bodies) {
              if (body.isStatic && body.position.y < H() - 60) {
                Body.setStatic(body, false);
                Body.setVelocity(body, { x: 0, y: 0 });
                Body.setAngularVelocity(body, 0);
              }
            }
          }, 50);

          if (onComplete) onComplete();
        }
      }, 100);
    }

    function init() {
      if (runner) {
        Runner.stop(runner);
        Render.stop(render);
        render.canvas.remove();
      }

      engine = Engine.create();
      world = engine.world;

      // Increase solver iterations to improve stability
      engine.positionIterations = 30;
      engine.velocityIterations = 10;
      engine.constraintIterations = 4;

      const canvas = document.getElementById('world');
      canvas.width = W();
      canvas.height = H();

      render = Render.create({
        canvas, engine,
        options: {
          width: W(),
          height: H(),
          background: getComputedStyle(document.body).getPropertyValue('--bg'),
          wireframes: false
        }
      });

      Render.run(render);
      runner = Runner.create();
      Runner.run(runner, engine);

      // Ground
      World.add(world, Bodies.rectangle(W() / 2, H() - 20, W(), 40, {
        isStatic: true,
        friction: 1.0,
        frictionStatic: 1.0,
        restitution: 0,
        render: { fillStyle: '#444' }
      }));

      buildTowerSlowly(15);

      const mouse = Mouse.create(render.canvas);
      World.add(world, MouseConstraint.create(engine, {
        mouse,
        constraint: { stiffness: 0.2, render: { visible: false } }
      }));
      render.mouse = mouse;
    }

    document.getElementById('btn').onclick = init;
    addEventListener('resize', () => {
      if (render && render.canvas) {
        render.canvas.width = W();
        render.canvas.height = H();
      }
    });

    init();
  </script>
</body>
</html>
